// equirect_to_cubemap.comp - Конвертация equirectangular HDR в cubemap
#version 450 core

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

// Input: equirectangular HDR текстура
layout(binding = 0) uniform sampler2D equirectangularMap;

// Output: cubemap (6 слоёв)
layout(binding = 1, rgba16f) uniform writeonly imageCube outputCubemap;

const float PI = 3.14159265359;

// Получить направление для текущего пикселя cubemap
vec3 GetCubemapDirection(uvec3 coord, uint face, uvec2 size) {
    vec2 uv = vec2(coord.xy) / vec2(size) * 2.0 - 1.0;
    
    vec3 dir;
    switch(face) {
        case 0: // +X (right)
            dir = vec3(1.0, -uv.y, -uv.x);
            break;
        case 1: // -X (left)
            dir = vec3(-1.0, -uv.y, uv.x);
            break;
        case 2: // +Y (top)
            dir = vec3(uv.x, 1.0, uv.y);
            break;
        case 3: // -Y (bottom)
            dir = vec3(uv.x, -1.0, -uv.y);
            break;
        case 4: // +Z (front)
            dir = vec3(uv.x, -uv.y, 1.0);
            break;
        case 5: // -Z (back)
            dir = vec3(-uv.x, -uv.y, -1.0);
            break;
    }
    
    return normalize(dir);
}

// Конвертировать 3D направление в UV координаты equirectangular карты
vec2 DirectionToEquirectangularUV(vec3 dir) {
    // Сферические координаты
    float phi = atan(dir.z, dir.x);   // азимут [-π, π]
    float theta = asin(dir.y);         // высота [-π/2, π/2]
    
    // Нормализуем в [0, 1]
    vec2 uv;
    uv.x = phi / (2.0 * PI) + 0.5;
    uv.y = theta / PI + 0.5;
    
    return uv;
}

void main() {
    uvec3 coord = gl_GlobalInvocationID;
    uvec2 size = imageSize(outputCubemap).xy;
    
    // Проверка границ
    if (coord.x >= size.x || coord.y >= size.y) return;
    
    // Обрабатываем все 6 граней
    for (uint face = 0; face < 6; face++) {
        // Получаем направление для этого пикселя
        vec3 direction = GetCubemapDirection(coord, face, size);
        
        // Конвертируем в UV координаты equirectangular карты
        vec2 uv = DirectionToEquirectangularUV(direction);
        
        // Сэмплируем HDR текстуру
        vec4 color = texture(equirectangularMap, uv);
        
        // Записываем в соответствующую грань cubemap
        imageStore(outputCubemap, ivec3(coord.xy, face), color);
    }
}